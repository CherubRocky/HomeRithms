\documentclass[11pt]{article}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb}
\usepackage{geometry}
\usepackage{setspace}
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{xurl}
\usepackage{listings}
\usepackage{tikz}
\usepackage{xcolor}
\usetikzlibrary{decorations.pathreplacing, calc}

\geometry{letterpaper, margin=2cm}

\lstset{escapeinside={(*}{*)}}

\begin{document}
\begin{titlepage}
    \centering
    \vspace{2cm}
    {\includegraphics[height=3.2cm]{../logo_unam.png}}
    \hfill
    {\includegraphics[height=3.2cm]{../logo_fc.png}\par}
    \vspace{1cm}
    {\bfseries\LARGE UNIVERSIDAD NACIONAL AUTÓNOMA DE MÉXICO \par}
    \vspace{0.7cm}
    {\scshape\Large FACULTAD DE CIENCIAS \par}
    \vspace{1cm}
    {\itshape\Large Lenguajes de programación \par}
    \vspace{0.5cm}
    {\itshape\Large Semestre 2026-1 \par}
    \vspace{2cm}
    {\scshape\Huge Tarea 9 \par}
    \vspace{1cm}
    {\itshape\Large Fecha de entrega: 08 de diciembre de 2025 \par}
    \vspace{2cm}
    {\Large Autores: \par}
    \vspace{0.4cm}
    {\Large Escobar Gonzalez Isaac Giovani \hspace{1cm} 321336400 \par}
    {\Large Garduño Escobar Kevin Jonathan \hspace{0.5cm} 321070629 \par}
    {\Large Zaldivar Alanis Rodrigo \hspace{2.75cm} 424029605 \par}
\end{titlepage}
\section*{Instrucciones}
\noindent Resolver los siguientes ejercicios de forma clara y ordenada de acuerdo a los lineamientos de entrega de tareas disponibles en la página del curso.\\
\section*{Ejercicios}

\begin{enumerate}[leftmargin=0.8cm]
    \item Define un macro que calculé el cuadrado de un número con la sintaxis vista en clases.\\
    \textbf{Solución:}\\
    Daremos la siguiente definición para el macro que calcula el cuadrado de un número usando la sintaxis vista en clases:
    \begin{verbatim}
(define-syntax my-sqr
  (syntax-rules ()
    [(my-sqr expr)
      (let ([x expr])
        (* x x))]))
\end{verbatim}
    Hacemos uso de \texttt{syntax-rules} para definir el macro \texttt{my-sqr}, que toma una expresión \texttt{expr} como argumento. Dentro del macro, usamos un \texttt{let} para evaluar la expresión y almacenar su valor en la variable \texttt{val}. Finalmente, retornamos el producto de \texttt{val} consigo mismo, que es el cuadrado de la expresión dada.

    \item Define los siguientes conceptos con tus propias palabras y en no más de cinco renglones
\begin{enumerate}[label=\alph*.]
        \item Variable de tipo: Son variables que esperan ser ligadas en una expresión y así realizar polimorfismo explícito en esta. Cuando son ligadas, determinan el tipo de la expresión y sus restricciones. Es como cuando al implementar listas en el curso de estructuras de datos en java, se utiliza el parámetro \texttt{<T>}. O los tipos $\tau$ que reciben las expresiones $\Lambda$ en Racket.
        \item Polimorfismo explícito: Es una manera de escribir expresiones análogas entre tipos de tal manera de que puedan recibir distintos tipos (abstrae estas expresiones en una sola).
        Pero fuerza al programador a especificar el tipo de la expresión que está dando. Como cuando declaras una lista genérica en java. (\texttt{new ArrayList<String>()}).
        \item Polimorfismo implícito: Es una manera de escribir expresiones análogas entre tipos de tal manera de que puedan recibir distintos tipos.
        A diferencia del polimorfismo explícito, no necesita que se especifique el tipo de expresión. Más bien, este es inferido. Función longitud en Racket (\texttt{length '(1 2 3)}).
    \end{enumerate}
    \item Toma en cuenta los siguiente códigos implementados en el lenguaje de programación Racket:
    \begin{itemize}
        \item \begin{lstlisting}[language=Lisp]
#lang plai-typed
        \end{lstlisting}
        \begin{lstlisting}[language=Lisp]
(define (mapea [funcion : ('A -> 'B)]
               [lista : (Listof 'A)]) : (Listof 'B)
  (if (empty? lista)
        empty
        (cons (funcion (first lista))
                (mapea funcion (rest lista)))))
        \end{lstlisting}
    \end{itemize}
    \begin{itemize}
        \item \begin{lstlisting}[language=Lisp]
#lang plai
        \end{lstlisting}
        \begin{lstlisting}[language=Lisp]
(define (mapea funcion lista)
  (if (empty? lista)
        empty
        (cons (funcion (first lista))
                (mapea funcion (rest lista)))))
        \end{lstlisting}
    \end{itemize}
    \begin{enumerate}[label=\alph*.]
        \item ¿Cuál de las 2 funciones mapea demuestra polimorfismo explícito y cual polimorfismo implícito? Justifica tu respuesta. \\
        \textbf{Solución:}\\
        Tenemos que la primera función \texttt{mapea} nos da un ejemplo de polimorfismo explícito, esto puesto que en la definición de la función vemos como se está especificando el tipo de los parámetros que recibe la función la cual va desde un tipo genérico \texttt{'A} a otro tipo genérico \texttt{'B}, a su vez que la lista es del tipo \texttt{(Listof 'A)} y el valor de retorno es del tipo \texttt{(Listof 'B)}. Dado esto anterior podemos observar como se está obligando los tipos de los parámetros que recibe la función y el tipo de retorno, por lo que se está haciendo uso de polimorfismo explícito.\\
        Mientras que la segunda función \texttt{mapea} nos da un ejemplo de polimorfismo implícito, pues en la definición de la función, al contrario de la primera función, no se está especificando el tipo de los parámetros que recibe la función o el tipo de retorno. Por lo que los tipos de los parámetros y el tipo de retorno serán "inferidos" (aunque en realidad no hay inferencia de tipos en \texttt{plai} como tal, simplemente no se especifican los tipos) en tiempo de ejecución, lo que nos indica que se está haciendo uso de polimorfismo implícito.\\
        Un detalle que podemos también considerar es que en la primera función se muestra que esta usando el lenguaje \texttt{plai-typed} y en la segunda función se está usando el lenguaje \texttt{plai}, lo que también nos sirve para justificar que la primera función hace uso de polimorfismo explícito y la segunda función hace uso de polimorfismo implícito.\\

        \item Si tuvieras que pasar una función \textit{funcion} que opera sobre números y una lista de números a ambas versiones de mapea, ¿existiría alguna diferencia en cómo se verifica el tipo de la función y los elementos de la lista en tiempo de compilación o ejecución entre la versión implícita y la explícita? Describe este proceso. \\
        \textbf{Solución:}\\
        Si, existiría una diferencia de acuerdo a que versión de \texttt{mapea} estemos utilizando, pues para el primer caso, al tratarse de polimorfismo explícito, el compilador verificará en tiempo de compilación que la función \texttt{funcion} que se está pasando como argumento a la función \texttt{mapea} sea del tipo \texttt{('A -> 'B)} y que la lista sea del tipo \texttt{(Listof 'A)}, donde \texttt{'A} y \texttt{'B} son tipos genéricos que pueden ser cualquier tipo de dato. Por lo que si la función o la lista no cumplen con estos tipos, el compilador generará un error en tiempo de compilación.\\
        Por otro lado, en el caso de hacer uso de la segunda versión de \texttt{mapea} (polimorfismo implícito), la verificación de tipos se realizará en tiempo de ejecución, es decir, no existe una verificación de tipos antes de ejecutar el programa. Por tanto, si la operación de la función \texttt{funcion} no es compatible con los elementos de la lista, se generará un error en tiempo de ejecución.\\
        En resumen, la diferencia trata sobre en que momento se realiza la verificación de tipos, ya sea en tiempo de compilación (polimorfismo explícito) o en tiempo de ejecución (polimorfismo implícito) y sus correspondientes errores que puedan llegar a mostrar.\\

    \end{enumerate}
    \item Investiga brevemente los siguientes conceptos del \textit{paradigma de programación Orientada a Objetos} con 3 diferentes \textit{Inteligencias Artificiales} por ejemplo \textit{ChatGpt, Gemini, DeepSeek, etc.} A partir del resultado realiza un pequeño resumen de cuales son las diferencias, similitudes y características particulares entre cada una de las respuestas de las diferentes \textit{Inteligencias Artificiales} que utilizaste.
    \begin{itemize}
        \item Clase
        \item Objeto
        \item Interfaz
        \item Clase Abstracta
        \item Encapsulamiento
        \item Herencia
        \item Polimorfismo
    \end{itemize}
    Una vez se hayan usado las diferentes \textit{Inteligencias Artificales}, cita de dónde obtuviste dicha información. Por ejemplo si la \textit{Inteligencia Artificial} te entregó el siguiente párrafo: "Párrafo de ejemplo...."[NUM-REF] ó "Según la información generada por ChatGPT (OpenAI, 1 de agosto de 2024),... ". ponerlo entre comillas dobles y citar usando numerado de referencias en un apartado al final de la tarea donde venga la bibliografía.\\
    Bibliografía\\
    $[1]$ OpenAI. (2024). ChatGPT (versión 3.5) [Modelo de lenguaje grande]. https://chat.openai.com/ [Consulta: 16 de agosto de ...]\\
    Otra manera de incluirlas las referencias es incluir el prompt propio de la respuesta:\\
    OpenAI. (2024). ChatGPT (versión 3.5) [Modelo de lenguaje grande]. https://chat.openai.com/ [Consulta: 16 de agosto de. Ver anexo para el prompt....]\\\\
    Nosotros realizamos la investigación acerca de los conceptos del paradigma de programación Orientada a Objetos utilizando las siguientes Inteligencias Artificiales: ChatGPT, Gemini y DeepSeek, de modo que obtuvimos las siguientes diferencias, similitudes y características particulares en sus respuestas:
    \subsection*{Diferencias}
    A pesar de que las tres inteligencias artificiales proporcionaron definiciones similares para los conceptos del paradigma de programación orientada a objetos, si hubieron algunas diferencias en las respuestas que obtuvimos.\\
    Empezando con que Gemini fue la única que dio un poco de contexto de que es la programación orientada a objetos antes de definir los conceptos, mientras que ChatGPT y DeepSeek fueron directos a las definiciones.\\
    En escensia las definiciones de los conceptos son lo mismo, pero la forma de redacción cambia y Gemini normalmente en cada concepto daba más información que las otras dos \textit{IA's}, explicando un poco más de como funciona o el porque o para que se utiliza cada concepto.\\
    Además, ChatGPT después de definir cada concepto daba un ejemplo concreto de cada uno pero en texto nada más mientras que DeepSeek después de cada definición nos dio un ejemplo con código en \texttt{Java} para cada concepto y Gemini no dio ningún ejemplo para ninguno de los conceptos pero si una analogía para que se entendiera mejor cada concepto.
    \subsection*{Similitudes}
    Las tres \textit{Inteligencias Artificales} tienen similitudes en sus respuestas que nos dieron para los conceptos. La principal similitud es que las tres \textit{IA's} definieron los conceptos de manera correcta y coherente, mostrando una buena explicación de los mismos.\\
    Otra similitud es que las tres \textit{IA's} utilizaron algo más que la definición para ilustrar los conceptos, lo que ayuda a entender mejor cada uno de ellos.\\
    Además, las tres \textit{IA's} relacionaron los conceptos entre sí, mostrando cómo se interconectan dentro del paradigma de programación orientada a objetos.\\
    Y también al final de las respuesta obtenidas de las \textit{IA's} nos daban opciones para seguir hablando más a fondo de la programación orientada a objetos ya sea profundizando en alguno de los conecptos, hablando de otros conceptos relacionados o dando ejemplos más complejos.
    \subsection*{Características particulares}
    Cada una de las \textit{Inteligencias Artificiales} tiene características particulares que las diferencian entre sí.\\
    ChatGPT se caracteriza más por su capacidad de generar las respuestas de manera consisa y clara, dando la información y ejemplos necesarios para entender los conceptos sin extenderse demasiado, de manera que la información sea fácil de digerir y no sobrecargue al usuario de cosas innecesarias.\\
    Gemini se caracteriza por su capacidad de dar explicaciones más detalladas y contextuales, proporcionando un poco más de información acerca de cada concepto, de manera que sea más fácil para el usuario entender dicho concepto dando un poco más de contexto y analogías de la vida real para que sea más fácil de entender pero puede ser un poco más pesado en información.\\
    Mientras que DeepSeek se caracteriza por su capacidad de proporcionar la información solicitada de manera clara y concreta pero centrandose más en ejemplos prácticos con código, muestra como sería la implementación de cada concepto en la programación orientada a objetos en el lenguaje \texttt{Java} incluyendo comentarios en el código.
    \item Toma en cuenta el siguiente código hecho en lenguaje de programación \textit{java}:\\
    \begin{lstlisting}[language=Java, frame=single, basicstyle=\ttfamily]
public class CuentaBancaria {
    private double saldo;
    private String titular;

}
    \end{lstlisting}
    \begin{enumerate}[label=\alph*.]
        \item ¿Por qué es importante el encapsulamiento de datos?\\
        \textbf{Solución:}\\
        Es muy importante el encapsulamiento de datos porque, como su nombre nos indica, nos permite encapsular o proteger los datos de una clase, evitando que se puedan modificar o acceder directamente desde fuera de la clase. Pues al encapsular los datos, podemos controlar cómo se accede y modifica la información, lo que ayuda a mantener la integridad y consistencia de los datos. También nos puede ser útil al momento de realizar cambios en la implementación interna de la clase, ya que si los datos están encapsulados, no afectará a otras partes del código que utilizan esa clase.

        \item Implementa un constructor para la clase \textbf{CuentaBancaria} que acepte valores iniciales para el saldo y el titular.\\
        \textbf{Solución:}\\ 
        Daremos el siguiente constructor para la clase \textbf{CuentaBancaria} que acepte dos parámetros, uno para el saldo inicial y otro para el nombre del titular de la cuenta bancaria. El constructor asignará estos valores a los atributos privados de la clase. Por lo que el constructor quedaría de la siguiente manera:\\
        \begin{lstlisting}[language=Java, frame=single, basicstyle=\ttfamily]
public CuentaBancaria(double saldo, String titular) {
    this.saldo = saldo;
    this.titular = titular;
}
        \end{lstlisting}
        
\lstset{
  showspaces=false,
  showstringspaces=false
}

        \item Proporciona un ejemplo de cómo crear una instancia de la clase \textbf{CuentaBancaria} y establece un saldo inicial y un nombre del titular de la cuenta.\\
        \textbf{Solución:}\\
        Para crear una instancia de la clase \textbf{CuentaBancaria} es necesario llamar al constructor de la clase con los parámetros necesarios los cuales establecimos en el punto anterior, necesitamos un saldo inicial y un nombre del titular de la cuenta, por ejemplo, lo podemos hacer de la siguiente manera:\\
        \begin{lstlisting}[language=Java, frame=single, basicstyle=\ttfamily]
CuentaBancaria cuentaB1 = new CuentaBancaria(99.9,"Alonzo Church");
        \end{lstlisting}

        \item Que ventaja tiene acceder a atributos de una clase con los métodos \textit{getter} y \textit{setter} en lugar de acceder directamente a los atributos fuera de la clase.\\
        \textbf{Solución:}\\
        La ventaja es que si contamos con los \textit{getter} podemos obtener el valor de un atributo privado sin modificarlo, y con los \textit{setter} podemos validar o controlar los valores que se asignan a los atributos privados, evitando así inconsistencias o errores en los datos. Pues siempre buscaremos mantener la integridad de los datos.\\
        Nos garantizan una mayor seguridad y control sobre dichas variables, evitandonos que no se existan modificaciones no deseadas o accesos indebidos a los atributos de la clase.

    \end{enumerate}
\end{enumerate}

\section*{Bibliografía:}
\noindent$[1]$ OpenAI. (2025). ChatGPT (versión GPT-4) [Modelo de lenguaje grande]. \url{https://chat.openai.com} [Consulta: 07 de diciembre de 2025].\\
\noindent$[2]$ Google. (2025). Gemini (versión 3.0 Pro) [Modelo de lenguaje grande]. \url{https://gemini.google.com} [Consulta: 07 de diciembre de 2025].\\
\noindent$[3]$ DeepSeek. (2025). DeepSeek Chat [Modelo de lenguaje grande]. \url{https://www.deepseek.com} [Consulta: 07 de diciembre de 2025].\\
\noindent Oracle. (2025). Object-Oriented Programming. Oracle. \url{https://www.oracle.com/java/technologies/oop.html} [Consulta: 08 de diciembre de 2025].

\end{document}
