\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish,es-noshorthands]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fullpage}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{algorithm2e}
\usepackage{float}
%% Sets page size and margins
\usepackage[a4paper,top=2.5cm,bottom=2.5cm,left=2cm,right=2cm]{geometry}


%% Title
\title{
		\vspace{-0.7in}
		\usefont{OT1}{bch}{b}{n}
		\begin{minipage}{3cm}
        \vspace{-0.5in}
    	\begin{center}
    		\includegraphics[height=3.2cm]{../logo_unam.png}
    	\end{center}
    \end{minipage}\hfill
    \begin{minipage}{10.7cm}

    	\begin{center}
\normalfont \normalsize \textsc{UNIVERSIDAD NACIONAL AUTÓNOMA DE MÉXICO \\ FACULTAD DE CIENCIAS \\ Análisis de Algoritmos } \\
		\huge Tarea 4
    	\end{center}

    \end{minipage}\hfill
    \begin{minipage}{3.2cm}
    \vspace{-0.5in}
    	\begin{center}
    		\includegraphics[height=3.2cm]{../logo_fc.png}
    	\end{center}
    \end{minipage}

\author{Escobar Gonzalez Isaac Giovani \hspace{1cm} 321336400\\
        Garduño Escobar Kevin Jonathan \hspace{0.5cm} 321070629\\
        Zaldivar Alanis Rodrigo \hspace{2.75cm} 424029605 }
\date{}
}

\begin{document}

\maketitle

\section*{Ejercicio 1}
\noindent Investiga en qué consiste el Algoritmo de Strassen
\begin{itemize}
    \item ¿Qué problema resuelve?
    \item ¿Por qué es importante?\\
    ¿cuál sería la alternativa ”trivial” para el problema que se resuelve?
    \item Escribe el pseudocódigo
    \item ¿Qué técnica de diseño de algoritmos utiliza?
    \item Ilustra la ejecución del algoritmo (en papel) con un ejemplar pequeño
\end{itemize}

\section*{Ejercicio 2}
\noindent Para cada uno de los siguientes ejercicios, propón el algoritmo, indica que técnica de diseño de algoritmos se utiliza, realiza el análisis de complejidad de tiempo e ilustra la ejecución con un ejemplar pequeño.
\begin{enumerate}
    \item[2.A] Dado un árbol binario, supón que los nodos solo contienen la información del padre, los hijos, y el valor actual, sin posibilidad de guardar información extra. Queremos determinar si el árbol es o no AVL.
    \item[2.B] Dado un arreglo de $n$ números, queremos encontrar la pareja ($i, j$) que maximiza la suma de los elementos desde la posición $i$ hasta la posición $j$; el algoritmo debería tener complejidad $O(n)$.
    \item[2.C] Dada una malla de tamaño $s \times t$, que contiene números no negativos, queremos encontrar una ruta desde la esquina superior izquierda hasta la esquina inferior derecha que minimice la suma de todos los números en la ruta. Los únicos movimientos permitidos son moverse hacia abajo o hacia la derecha.\\
    Nota: No es válida la solución con el algoritmo de Dijkstra, se debe usar una técnica basada en inducción.
\end{enumerate}

\section*{Ejercicio 3}
\noindent Queremos almacenar $n$ programas, $P_1, P_2, \ldots, P_n$ $n$, en una unidad de almacenamiento con capacidad máxima $D$. Para cada programa $P_i$, se conoce su tamaño $s_i$, y se sabe que no es posible almacenar todos los programas (al mismo tiempo) en la unidad de almacenamiento.
\begin{enumerate}
    \item[3.A] ¿Un algoritmo que almacena los programas seleccionando en orden no decreciente $s_i$ maximiza el número de programas que se pueden mantener en la unidad? Prueba o da un contraejemplo.\\
    \textbf{Solución:} Esta afirmación es cierta, ya que al seleccionar los programas en orden no decreciente de tamaño, se asegura que se están utilizando los espacios más pequeños primero, lo que permite almacenar la mayor cantidad posible de programas antes de alcanzar la capacidad máxima $D$ de la unidad de almacenamiento.\\
    Daremos un algoritmo que implementa esta idea:\\
    \RestyleAlgo{ruled}
    \LinesNumbered
    \renewcommand{\algorithmcfname}{Algoritmo}
    \begin{algorithm}[H]
        \caption{Almacena programas en orden no decreciente de tamaño y selecciona la mayor cantidad posible}
        \KwIn{Lista de los tamaños de los programas $s_1, s_2, \ldots, s_n$ y la capacidad máxima $D$}
        \KwOut{Número programas almacenados}
        $numProgramas \gets 0$\\
        $peso \gets 0$\\
        Ordenar los tamaños de los programas en orden no decreciente\\
        \For{$i \gets 0$ \textbf{to} $n$}{
            \If{$peso + s_i \leq D$}{
                $peso \gets peso + s_i$\\
                $numProgramas \gets numProgramas + 1$\\
            }
            \Else{
                \textbf{break}\\
            } 
        }
        \Return $numProgramas$
    \end{algorithm}
    \textbf{Análisis de correctitud:}\\
    Si tomamos como invariante que al inicio de la i-ésima iteración $numProgramas$ es el máximo número de programas que se pueden almacenar usando únicamente los primeros $i$ programas más pequeños.
    \begin{itemize}
        \item \textbf{Inicialización: } Antes de la primera iteración, no se ha considerado ningún programa, por lo que $numProgramas = 0$ lo que es correcto.
        \item \textbf{Mantenimiento: } Supongamos que al inicio de la i-ésima iteración, $numProgramas$ ha almacenado la mayor cantidad posible de programas con los primeros $i-1$ tamaños. En la i-ésima iteración, si el tamaño del programa $s_i$ puede ser almacenado sin exceder la capacidad máxima $D$, entonces se almacena y se incrementa $numProgramas$ en 1, esto sigue cumpliendo la invariante ya que se ha almacenado la mayor cantidad posible de programas con los primeros $i$ tamaños para antes de la (i+1)-ésima iteración. Si el tamaño del programa $s_i$ no puede ser almacenado sin exceder la capacidad máxima $D$, entonces se detiene el proceso, ya que todos los programas restantes son más grandes y no podrán ser almacenados tampoco, por lo que $numProgramas$ sigue siendo la mayor cantidad posible de programas almacenados con los primeros $i-1$ tamaños.
        \item \textbf{Terminación: } Si se llegua al caso donde el peso ya acumulado más el tamaño del siguiente programa excede la capacidad máxima $D$, el ciclo acaba, el algoritmo se detiene y retorna $numProgramas$, que es la mayor cantidad posible de programas almacenados sin exceder la capacidad máxima $D$, por lo que ya no hay más iteraciones que realizar y la invariante se mantiene.\\
        Si no se llega a ese caso y se hacen todas las iteraciones del ciclo, entonces se han considerado todos los programas y se ha almacenado la mayor cantidad posible de programas sin exceder la capacidad máxima $D$, por lo que el algoritmo es correcto, aunque la el enunciado menciona que no es posible almacenar todos los programas al mismo tiempo, por lo que este caso no se da.
    \end{itemize}
    Por lo tanto, el algoritmo es correcto y maximiza el número de programas que se pueden mantener en la unidad de almacenamiento.
    \item[3.B] ¿Un algoritmo que selecciona en orden no creciente $s_i$ utiliza la mayor capacidad del disco? Prueba o da un contraejemplo.\\
    \textbf{Solución:} Esta afirmación es falsa, ya que al seleccionar los programas en orden no creciente, podemos caer en el caso de que se seleccionen programas grandes que ocupen mucho espacio pero no la mayor cantidad posible a comparación de lo que podría pasar con otra selección.\\
    Por ejemplo, supongamos que tenemos una unidad de almacenamiento con capacidad máxima $D = 10$ y los siguientes tamaños de programas: $s_1 = 8$, $s_2 = 7$, $s_3 = 3$, $s_4 = 1$. Si aplicamos este algoritmo, seleccionariamos primero $s_1 = 8$, luego $s_2 = 7$ (no cabe), luego $s_3 = 3$ (no cabe), y finalmente $s_4 = 1$ (cabe). En total, habríamos utilizado $8 + 1 = 9$ unidades de espacio.\\
    Mientras que si hubiéramos seleccionado $s_2 = 7$ y $s_3 = 3$, habríamos utilizado exactamente $10$ unidades de espacio, que es la capacidad máxima de la unidad de almacenamiento.\\
    Por lo tanto, el algoritmo que selecciona en orden no creciente no garantiza utilizar la mayor capacidad del disco.
\end{enumerate}

\section*{Ejercicio 4}
\noindent Considera un país cuyas monedas son emitidas en denominaciones de $\{ d_1, \ldots, d_k $. Queremos un algoritmo para obtener una cantidad $monto$ utilizando el mínimo número de monedas.
\begin{enumerate}
    \item[4.A] Considera un algoritmo que selecciona siempre la moneda más grande que no sea mayor que la cantidad que debe ser entregada, repitiendo el proceso hasta llegar a cero. Muestra que dicho algoritmo no siempre utiliza el mínimo número de monedas, ejemplificando con un caso con las siguientes denominaciones: $ \{ 1, 6, 10 \}$\\\\
    Proponemos la cantidad $monto = 13$.\\
    La mayor moneda que podemos elegir es 10. Luego, solo queda completar $monto = 3$.
    La mayor moneda que podemos elegir para completar 3 es 1. Queda completar $monto = 2$.\\
    La mayor moneda que podemos elegir para completar 2 es 1. Queda completar $monto = 1$.\\
    La mayor moneda que podemos elegir para completar 1 es 1. Ya no queda completar nada.\\
    De esta manera, el algoritmo que selecciona la moneda más grande nos devuelve 4 monedas. Una de $10$ y 3 de $1$.\\
    Sin embargo, vemos que existe otra combinación con menor cantidad de monedas que nos da el mismo monto: (6, 6, 1). Suman 13 en total.\\
    Por lo que el algoritmo que selecciona la moneda más grande no minimiza en todos los casos la cantidad de monedas para completar un monto.
    \newpage
    \item[4.B] Propón un algoritmo eficiente que determine correctamente el mínimo número de monedas que se necesitan para obtener una cantidad $n$ utilizando las denominaciones dadas. Menciona que técnica de diseño se utiliza y analiza la complejidad de tiempo.\\\\
    Proponemos el siguiente algoritmo:\\
    ($monto$, $M$, $n$)\\
    Donde $M$ es un arreglo que contiene las monedas con sus denominaciones y $n$ es el tamaño del arreglo.
    \begin{algorithm}
        \caption{Minimizar monedas}
        \If{monto = 0}{
            \Return 0\;
        }
        $m \gets monto + 1$\;
        $T \gets$ newArray[m]\;
        $T[0] \gets 0$\;
        \For{$i \gets 0$ \KwTo n - 1}{
            \If{$M[i] \leq monto$}{
                $T[M[i]] \gets 1$\;
            }
        }
    
        \For{$i \gets 0$ \KwTo m - 1}{
            \If{$T[i] \lneq 0$}{
                continue\;
            }
            $min \gets \infty$\;
            \For{$k \gets 0$ \KwTo n - 1}{
                $diff \gets i - M[k]$\;
                \If{$diff > 0$ $\And$ $T[diff] \neq 0$}{
                    $min \gets Min(min, T[diff] + 1)$\;
                }
            }
            \If{$min \neq \infty$}{
                $T[i] \gets min$\;
            }
        }
        \If{$T[monto] == 0$}{
            \Return $-1$\;
        }
        \Return T[monto]\;
    \end{algorithm}

    Para este algoritmo se utilizó programación dinámica (DP).\\
    Se utilizó un arreglo con índices desde cero hasta monto. Se va calculando la cantidad mínima de monedas requeridas para llegar al monto a partir de soluciones guardadas para montos más pequeños. Si al sumar el valor de una moneda con el índice de una cantidad ya procesada (y guardada), esta se convierte en una solución candidata para el monto original. Tenemos que encontrar la solución candidata que requiera la menor cantidad de monedas.\\\\
    \textbf{Análisis de complejidad:}\\
    El primer condicional es constante. Después, se crea un arreglo de longitud $monto + 1$ para guardar las soluciones a los distintos montos. Esto es $O(monto)$.\\
    Luego, se recorre el todo arreglo de las monedas, como su cuerpo tiene complejidad $O(1)$, el ciclo en total tiene complejidad $O(n)$ porque hace $n$ iteraciones.\\
    Luego, tenemos un ciclo que hace $monto$ iteraciones.
    En la complejidad de su cuerpo, tenemos un condicional y una asignación que son constantes. Después, se ejecuta un ciclo anidado que se ejecuta $n$ veces. En el cuerpo del ciclo anidado, se hacen operaciones básicas, condicionales y asignaciones, por lo que el cuerpo de este tiene complejidad constante. Por lo que el ciclo anidado tiene una complejidad total de $O(n) \cdot O(1) = O/(n)$.  Después del ciclo anidado se tiene una condicional, que es constante. Por lo que el segundo ciclo del código tiene una complejidad de: $O(monto) (O(1) + O(n) + O(1)) = O(monto \cdot n)$.\\
    Luego del segundo for, tenemos un condicional con un return y después otro return. Las son instrucciones con complejidad constante. Por lo anterior, la complejidad del algoritmo se ve acotada por la complejidad del segundo ciclo. Por lo que el algoritmo $\in$ $O(monto \cdot n)$.
    
    
    \item[4.C] Da un algoritmo eficiente para calcular $C(n)$: el número de formas distintas de obtener una cantidad $monto$ con las denominaciones dadas.\\
    Si se asume que en las formas distintas no importa el orden, tenemos el siguiente algoritmo:
    ($monto$, $M$, $n$)\\
    Donde $M$ es un arreglo que contiene las monedas con sus denominaciones y $n$ es el tamaño del arreglo.
    \begin{algorithm}
        \caption{Combinaciones}
        $m \gets monto + 1$\;
        $T \gets$ newArray[m]\;
        $T[0] \gets 1$\;
        \For{$j \gets 0$ \KwTo $n - 1$}{
            \For{$i \gets M[j]$ \KwTo monto}{
                $diff \gets i - M[j]$\;
                \If{$diff \geq 0$}{
                    $T[i] += T[diff]$
                }
            }
        }
    \end{algorithm}\\
    Análogo al inciso anterior, este tine complejidad $O(n * monto)$ porque hay un ciclo externo que itera n veces y el interno itera $monto$ veces por cada iteración del externo. Además de que el cuerpo del ciclo externo tiene complejidad $O(1)$ y las demás instrucciones del ciclo externo también tienen complejidad $O(1)$.

    Si piden permutaciones, el siguiente algoritmo resutleve el problema.\\
    \begin{algorithm}[H]
    \caption{Permutaciones}
    
    $m \gets monto + 1$\;
    $T \gets \text{newArray}[m]$\;
    $T[0] \gets 0$\;
    
    \For{$i \gets 0$ \KwTo monto}{
        \For{$k \gets 0$ \KwTo $n - 1$}{
            $diff \gets i - M[k]$\;
            \If{$diff > 0$}{
                $T[i] \gets (T[i] + T[diff])$\;
            }
            \If{$diff = 0$}{
                $T[i] \gets (T[i] + 1)$\;
            }
        }
    }

    Análogamente al algoritmo anterior, la complejidad es $O(monto \cdot n)$, aunque en este caso, los ciclos for están "invertidos".
    \Return $T[monto]$\;
    \end{algorithm}
\end{enumerate}

\section*{Ejercicio 5}
\noindent Sea $A$ una colección de objetos. Describe un algoritmo eficiente para convertir $A$ en un conjunto; se deben eliminar todos los elementos duplicados de $A$. Da el análisis de complejidad de tiempo.\\
Se crea un arreglo del doble del tamaño de A. Después se utiliza una función de dispersión para obtener un entero en el rango a partir del objeto. Se guarda el objeto en una lista almacenada en la posición del arreglo (esto es para manejar colisiones). Para ver si el elemento es repetido, lo comparamos con los elementos (en caso de haber) de la lista. Si el objeto ya ha sido agregado, no hacemos nada. En caso contrario, se agrega al final de la lista. Además, utilizaremos otra lista(ArrayList), que será la que se devolverá como conjunto. Si y solo si se agrega un objeto en la lista subyacente del arreglo, se agrega en la lista de retorno. \\
Primero daremos el algoritmo de la función de dispersión de Daniel J. Bernstein (Peláez Valdés, 2018).\\
\textbf{Entrada:} (llave (arreglo de bytes))\\
\begin{algorithm}[H]
 \caption{Función de Dispersión de Bernstein}
 $h \gets 5381$\;
 
 \For{$i \gets 0$ \KwTo $n - 1$}{
  $h \gets (h \cdot 33) + llave[i]$\;
 }
 \Return $h$\;
\end{algorithm}

\newpage
\textbf{Entrada:} Colección de objetos A de tamaño n\\
\textbf{Salida:} Arreglo con conjuntos\\\\
\begin{algorithm}[H]
 \caption{Conjuntar}
 $m \gets \text{2n}$\; 
 $arr \gets \text{newArray}[m]$\;
 
 \For{$i \gets 0$ \KwTo $m - 1$}{
  $arr[i] \gets \text{newLinkedList()}$\;
 }
 
 $C \gets \text{newArrayList()}$\;
 
 \For{$j \gets 0$ \KwTo $n - 1$}{
  $obj \gets A[j]$\;
  $i \gets (\text{dispersaDJB(obj))}$ mod $ m$\;
  \If{!arr[i].contains(obj)}{
    arr[i].add(obj)\;
    C.add(obj)\;
  }
 }
 \Return $C$\;
\end{algorithm}

La complejidad es $O(n^2)$. En el peor caso, todos los objetos colisionan y son distintos. Para saber si el objeto ya existe en la lista en el índice del arreglo, esta se recorre completamente y se compara. En total, se harían $n(n - 1)/2$ comparaciones, por lo que es cuadrático.\\
Aunque en lo general, si se ocupa una función de dispersión buena y objetos aleatorios, esta tiene complejidad $O(n)$ amortizado, ya que los objetos tienen bajo índice de colisión.

\section*{Ejercicio 6}
\noindent Sean $A, B$ dos arreglos arbitrarios, de tamaño $m, n$ respectivamente. Una subsecuencia común de $A$ y $B$ es una secuencia que aparece en $A$ y en $B$.\\
Por ejemplo, $C$, $GRAM$, $OAIO$, \textit{P ROGRAM ACION} son subsecuencias de la cadena\\
$PROGRAMACION$
\begin{enumerate}
    \item[6.A] Describe un algoritmo recursivo (utilizando backtracking) para determinar si $X$ es una subsecuencia de $Y$.\\
    \textbf{Solución:} El algoritmo recursivo con backtracking es el siguiente:\\
    \RestyleAlgo{ruled}
    \LinesNumbered
    \renewcommand{\algorithmcfname}{Algoritmo}
    \begin{algorithm}[H]
        \caption{Determina si $X$ es una subsecuencia de $Y$}
        \KwIn{Cadenas $X$ y $Y$, índices $i$ y $j$}
        \KwOut{Verdadero si $X$ es una subsecuencia de $Y$, falso en caso contrario}
        \If{$i < 0$}{
            \Return \textbf{true}\\
        }
        \ElseIf{$j < 0 \; \&\& \; i \geq 0$}{
            \Return \textbf{false}\\
        }
        \ElseIf{$X[i] == Y[j]$}{
            \Return $isSubsequence(X, Y, i-1, j-1) || isSubsequence(X, Y, i, j-1)$\\
        }
        \Else{
            \Return $isSubsequence(X, Y, i, j-1)$\\
        }
    \end{algorithm}
    Ahora, un pequeño ejemplo de ejecución para poder mostrar cómo funciona el algoritmo.\\
    Sea $X = \text{"RGR"}$ y $Y = \text{"ROGAR"}$.\\
    Llamamos a la función $isSubsequence(X, Y, 2, 4)$, donde 2 y 4 son los índices de los últimos caracteres de $X$ y $Y$, respectivamente.
    \begin{itemize}
        \item $i \nless 0$ y $j \nless 0$, entonces, comparamos $X[2]$ con $Y[4]$: son iguales (R == R), llamamos a $isSubsequence(X, Y, 1, 3)$ y $isSubsequence(X, Y, 2, 3)$.
        \item[-] Para $isSubsequence(X, Y, 1, 3)$:
        \begin{itemize}
            \item $i \nless 0$ y $j \nless 0$, entonces, comparamos $X[1]$ con $Y[3]$: no son iguales (G != A), llamamos a $isSubsequence(X, Y, 1, 2)$.
            \item $i \nless 0$ y $j \nless 0$, entonces, comparamos $X[1]$ con $Y[2]$: son iguales (G == G), llamamos a $isSubsequence(X, Y, 0, 1)$ y $isSubsequence(X, Y, 1, 1)$.
            \item[-] Para $isSubsequence(X, Y, 0, 1)$:
            \begin{itemize}
                \item $i \nless 0$ y $j \nless 0$, entonces, comparamos $X[0]$ con $Y[1]$: no son iguales (R != O), llamamos a $isSubsequence(X, Y, 0, 0)$.
                \item $i \nless 0$ y $j \nless 0$, entonces, comparamos $X[0]$ con $Y[0]$: son iguales (R == R), llamamos a $isSubsequence(X, Y, -1, -1)$ y $isSubsequence(X, Y, 0, -1)$.
                \item[-] Para $isSubsequence(X, Y, -1, -1)$:
                \begin{itemize}
                    \item $i < 0$, retornamos \textbf{true}.
                \end{itemize}
                \item[-] Para $isSubsequence(X, Y, 0, -1)$:
                \begin{itemize}
                    \item $j < 0$ y $i \geq 0$, retornamos \textbf{false}.
                \end{itemize}
            \end{itemize}
            \item[-] Para $isSubsequence(X, Y, 1, 1)$:
            \begin{itemize}
                \item $i \nless 0$ y $j \nless 0$, entonces, comparamos $X[1]$ con $Y[1]$: no son iguales (G != O), llamamos a $isSubsequence(X, Y, 1, 0)$.
                \item $i \nless 0$ y $j \nless 0$, entonces, comparamos $X[1]$ con $Y[0]$: no son iguales (G != R), llamamos a $isSubsequence(X, Y, 1, -1)$.
                \item $j < 0$ y $i \geq 0$, retornamos \textbf{false}.
            \end{itemize}
        \end{itemize}
        \item[-] Para $isSubsequence(X, Y, 2, 3)$:
        \begin{itemize}
            \item $i \nless 0$ y $j \nless 0$, entonces, comparamos $X[2]$ con $Y[3]$: no son iguales (R != A), llamamos a $isSubsequence(X, Y, 2, 2)$.
            \item $i \nless 0$ y $j \nless 0$, entonces, comparamos $X[2]$ con $Y[2]$: no son iguales (R != G), llamamos a $isSubsequence(X, Y, 2, 1)$.
            \item $i \nless 0$ y $j \nless 0$, entonces, comparamos $X[2]$ con $Y[1]$: no son iguales (R != O), llamamos a $isSubsequence(X, Y, 2, 0)$.
            \item $i \nless 0$ y $j \nless 0$, entonces, comparamos $X[2]$ con $Y[0]$: son iguales (R == R), llamamos a $isSubsequence(X, Y, 1, -1)$ y $isSubsequence(X, Y, 2, -1)$.
            \item[-] Para $isSubsequence(X, Y, 1, -1)$:
            \begin{itemize}
                \item $j < 0$ y $i \geq 0$, retornamos \textbf{false}.
            \end{itemize}
            \item[-] Para $isSubsequence(X, Y, 2, -1)$:
            \begin{itemize}
                \item $j < 0$ y $i \geq 0$, retornamos \textbf{false}.
            \end{itemize}
        \end{itemize}
    \end{itemize}
    Al final de toda la ejecución, obtenemos que $X$ es una subsecuencia de $Y$ ya que en una de las ramas del árbol de recursión se retorna \textbf{true}.
    \item[6.B] Da una definición recursiva simple para la función $lcs(A, B)$ que calcula la longitud de la subsecuencia común más grande de $A$ y $B$.\\
    \textbf{Solución:} En este caso, dado que estamos buscando la longitud de la subsecuencia común más larga de manera recursiva, vamos a cambiar los parámetros de la función para que pueda recibir los índices actuales en las cadenas $A$ y $B$, para que no tenga que estar copiando las cadenas en cada llamada recursiva. La definición recursiva sería la siguiente:\\
    \[
    lcs(A, B, i, j) =
    \begin{cases}
    0 & \text{si } i < 0 \text{ o } j < 0 \\
    1 + lcs(A, B, i-1, j-1) & \text{si } A[i] = B[j] \\
    \max(lcs(A, B, i-1, j), lcs(A, B, i, j-1)) & \text{si } A[i] \neq B[j]
    \end{cases}
    \]
    \item[6.C] Describe un algoritmo eficiente para calcular la longitud de la subsecuencia común más larga de $A$ y $B$. ¿Qué técnica de diseño se utiliza? Da el análisis de complejidad de tiempo.\\
    \textbf{Solución:} El algoritmo eficiente para calcular la longitud de la subsecuencia común más larga de $A$ y $B$ sería el siguiente:\\
    \RestyleAlgo{ruled}
    \LinesNumbered
    \renewcommand{\algorithmcfname}{Algoritmo}
    \begin{algorithm}[H]
        \caption{Calcula la longitud de la subsecuencia común más larga de $A$ y $B$}
        \KwIn{Cadenas $A$ y $B$}
        \KwOut{Longitud de la subsecuencia común más larga}
        $n \gets \text{longitud}(A)$\\
        $m \gets \text{longitud}(B)$\\
        $dp \gets \text{matriz}(n+1, m+1)$ \tcp*{Inicializar matriz de tamaño (n+1) x (m+1) con ceros}
        \For{$i \gets 1$ \KwTo $n$}{
            \For{$j \gets 1$ \KwTo $m$}{
                \If{$A[i-1] == B[j-1]$}{
                    $dp[i][j] \gets dp[i-1][j-1] + 1$\\
                }
                \Else{
                    $dp[i][j] \gets \max(dp[i-1][j], dp[i][j-1])$\\
                }
            }
        }
        \Return $dp[n][m]$
    \end{algorithm}
    El algoritmo consiste en construir una matriz $dp$ donde cada entrada $dp[i][j]$ representa la longitud de la subsecuencia común más larga entre las primeras $i$ letras de $A$ y las primeras $j$ letras de $B$. Por cada fila, recorremos las columnas y si la letra coincide en ambas cadenas entonces $dp[i][j]$ sera igual a $1 + dp[i-1][j-1]$, de lo contrario sera el maximo entre $dp[i-1][j]$ y $dp[i][j-1]$. Al final, la longitud de la subsecuencia común más larga estará en $dp[n][m]$.\\
    Este algoritmo utiliza la técnica de diseño de programación dinámica.\\
    \textbf{Análisis de complejidad de tiempo:}\\
    La complejidad de tiempo del algoritmo es $O(n \times m)$, donde $n$ y $m$ son las longitudes de las cadenas $A$ y $B$, respectivamente. Ya que se va a recorrer una matriz de tamaño $(n+1) \times (m+1)$, realizando operaciones constantes en cada celda para poder asignar su valor.
    \item[6.D] Una supersecuencia común de $A, B$ es otra secuencia que contiene las secuencias $A$ y $B$ como subsecuencias. Describe un algoritmo eficiente para calcular la longitud de la supersecuencia común más corta de $A$ y $B$. ¿Qué técnica de diseño se utiliza? Da el análisis de complejidad de tiempo.\\
    \textbf{Solución:} Para calcular la longitud de la supersecuencia común más corta de $A$ y $B$, podemos primero obtener la longitud de la subsecuencia común más larga entre $A$ y $B$, y luego utilizar eso para calcular la longitud de la supersecuencia común más corta, ya que para obtener la longitud de la supersecuencia común más corta, podemos usar la fórmula:
    \[\text{longitud supersecuencia} = \text{len}(A) + \text{len}(B) - LCS(A, B)\]
    Ya que, una vez obtenida la longitud de la subsecuencia común más larga, podemos restarla de la suma de las longitudes de ambas cadenas para evitar contar dos veces los caracteres que están en la subsecuencia común y simplemente agregar los caracteres restantes de ambas cadenas.\\
    Por lo tanto, el algoritmo sería casi idéntico al del inciso anterior, quedando de la siguiente manera:\\
    \RestyleAlgo{ruled}
    \LinesNumbered
    \renewcommand{\algorithmcfname}{Algoritmo}
    \begin{algorithm}[H]
        \caption{Calcula la longitud de la supersecuencia común más corta de $A$ y $B$}
        \KwIn{Cadenas $A$ y $B$}
        \KwOut{Longitud de la supersecuencia común más corta}
        $n \gets \text{longitud}(A)$\\
        $m \gets \text{longitud}(B)$\\
        $dp \gets \text{matriz}(n+1, m+1)$ \tcp*{Inicializar matriz de tamaño (n+1) x (m+1) con ceros}
        \For{$i \gets 1$ \KwTo $n$}{
            \For{$j \gets 1$ \KwTo $m$}{
                \If{$A[i-1] == B[j-1]$}{
                    $dp[i][j] \gets dp[i-1][j-1] + 1$\\
                }
                \Else{
                    $dp[i][j] \gets \max(dp[i-1][j], dp[i][j-1])$\\
                }
            }
        }
        \Return $ n + m - dp[n][m]$
    \end{algorithm}
    Como vemos, este algoritmo lo único que cambia con respecto al del inciso anterior es el return, en donde se calcula el número de caracteres que debe tener la supersecuencia común, con los caracteres que estan en ambas cadenas y los que no.\\
    Este algoritmo también utiliza la técnica de diseño de programación dinámica.\\
    \textbf{Análisis de complejidad de tiempo:}\\
    La complejidad de tiempo del algoritmo es también $O(n \times m)$, donde $n$ y $m$ son las longitudes de las cadenas $A$ y $B$, respectivamente. Ya que se va a recorrer una matriz de tamaño $(n+1) \times (m+1)$, realizando operaciones constantes en cada celda para poder asignar su valor.
\end{enumerate}

\section*{Ejercicio 7}
\noindent Sea $S$ un arreglo de $n$ números en la cual se tiene definida una relación de orden total. Una \textbf{inversión} en $S$ es un par de elementos $(i, j)$ tales que $i < j$ pero $S[i] > S[j]$. Describe un algoritmo eficiente para determinar el número de inversiones que hay en $S$. Da el análisis de complejidad e ilustra la ejecución de tu algoritmo con un ejemplar pequeño. ¿Qué técnica de diseño se utiliza?

\section*{Bibliografía}
\begin{itemize}
    \item Peláez Valdés, C. (2018). Estructuras de datos con Java moderno. Las Prensas de Ciencias.
\end{itemize}

\end{document}
